/**********************************************************************/
/*
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.

Copyright (c) 2013, Acuity Brands, Inc.

Author: Philip Nye <philip.nye@engarts.com>

This file forms part of Acacian a full featured implementation of 
ANSI E1.17 Architecture for Control Networks (ACN)

#tabs=3
*/
/**********************************************************************/
/*
file: bvactions.c

Functions to handle specific DDL behaviors.

These functions are called during parsing when the behavior declaration is
encountered. They are passed a pointer to a dcxt_s which provides all the 
necessary context in the property tree and a pointer together with the behavior
set and name. A single function typically handles multiple closely related 
behaviors and/or equivalent behaviors from several behaviorsets.

The functions here are connected to specific behavior and behaviorset definitions
by the macros in <bvactions.h> which are in turn used in sources like 
<bvset_acnbase.c> which are autogenerated from the behaviorset DDL itself.

topic: adding tasks for subsequent actions
Most behaviors can be processed immediately they are encountered in the parse.
At this point the property to which the behavior applies and all its ancestors
are defined. However, the content of the current property and details of its 
value are not yet known. If more information is requiredd in order to complete
the processing a task can be registered using <add_proptask> which will ba called
when the end tag of the property is eached, by which time the content will 
also have been parsed.
*/

#include <expat.h>
#include <assert.h>
#include "acn.h"

/**********************************************************************/
/*
Logging facility
*/

#define lgFCTY LOG_DDL

/**********************************************************************/
/*
group: Null and abstract behaviors

func: null_bva

Handle a NULL behavior. Just log it for debugging purposes.
*/
	/*
void
null_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	acnlogmark(lgDBUG, "     behavior %s: no action", bv->name);
}
	*/
#define null_bva NULL
/**********************************************************************/
/*
func: abstract_bva

Many behaviors are defined as abstract - 
they are used for refinement
but should not be applied directly to properties so we log a warning.
*/

	/*
void
abstract_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	acnlogmark(lgWARN,
			"     Abstract behavior %s used. Pleas use a refinement.",
			bv->name);
}
	*/
#define abstract_bva NULL
/**********************************************************************/
/*
group: Property flag behaviors

The dmp property structure includes flags for access permissions read,
write and event. This is extended by defining flags for a number of 
access qualifiers such as `persistent` and similar behaviors.
*/
/**********************************************************************/
/*
func: setbvflag

Set property flags. Called by several behavior actions.
Only makes sense on net properties.
FIXME: More sophisticated errror checking needed e.g. a constant flag
applied to an immediate property is not really an error - just redundant
*/

void
setbvflg(struct ddlprop_s *pp, enum netflags_e flag)
{
	struct dmpprop_s *np;
	if (pp->vtype != VT_network) {
		if (flag != pflg(constant)) {
			acnlogmark(lgERR,
				"%24s: access class (0x%04x) on non-network property",
				propxpath(pp), flag);
		}
		return;
	}
	np = pp->v.net.dmp;
	flag |= np->flags;

	/* perform some sanity checks */
	if ((flag & pflg(constant)) && (flag & (pflg(volatile) | pflg(persistent)))) {
		acnlogmark(lgERR,
			"%24s: constant property cannot also be volatile or persistent",
			propxpath(pp));
		return;
	}
	np->flags = flag;

#if acntestlog(lgDBUG)
	char buf[pflg_NAMELEN + pflg_COUNT];
	acnlogmark(lgDBUG,
		"%24s:%s", propxpath(pp), flagnames(flag, pflgnames, buf, " %s"));
#endif
}

/**********************************************************************/
/*
func: persistent_bva

behavior - persistent
behaviorsets - acnbase, acnbase-r2
*/
void
persistent_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setbvflg(pp, pflg(persistent));
}

/**********************************************************************/
/*
behavior: constant
behaviorsets: acnbase, acnbase-r2
*/

void
constant_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setbvflg(pp, pflg(constant));
}

/**********************************************************************/
/*
behavior: volatile
behaviorsets: acnbase, acnbase-r2
*/

void
volatile_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setbvflg(pp, pflg(volatile));
}


/**********************************************************************/
/*
group: Property encoding behaviors

Behaviors that define basic property encodings {integer, string, etc.}

func: setptype

Set encoding type
only make sense for network properties
*/

#define SZ_1   1
#define SZ_2   2
#define SZ_4   4
#define SZ_8   8
#define SZ_16 0x10
#define SZ_6  0x20
/* any fixed size */
#define SZ_AF 0x4000
#define SZ_V  0x8000

void
setptype(struct ddlprop_s *pp, enum proptype_e type, unsigned int sizes)
{
	struct dmpprop_s *np;

	if (pp->vtype != VT_network) {
		acnlogmark(lgDBUG,
			"%24s: ignoring type/encoding behavior on non-network property",
			propxpath(pp));
		return;
	}
	np = pp->v.net.dmp;
	if (np->flags & pflg(vsize)) {
		if (!(sizes &= SZ_V)) {
			acnlogmark(lgERR, "%24s: %s cannot be variable size",
				propxpath(pp), etypes[type]);
			return;
		}
	} else {
		if (sizes == SZ_V) {
			acnlogmark(lgERR, "%24s: %s must be variable size",
				propxpath(pp), etypes[type]);
			return;
		}
		switch (np->size) {
		case 1: sizes &= (SZ_1 | SZ_AF); break;
		case 2: sizes &= (SZ_2 | SZ_AF); break;
		case 4: sizes &= (SZ_4 | SZ_AF); break;
		case 6: sizes &= (SZ_6 | SZ_AF); break;
		case 8: sizes &= (SZ_8 | SZ_AF); break;
		case 16: sizes &= (SZ_16 | SZ_AF); break;
		default: sizes &= SZ_AF; break;
		}
		if (sizes == 0) {
			acnlogmark(lgERR, "%24s: %s is unsupported size (%u)",
				propxpath(pp), etypes[type], np->size);
			return;
		}
	}
	if (np->etype && np->etype != type) {
		acnlogmark(lgINFO,
			"%24s: overriding %s with %s", 
			propxpath(pp), etypes[np->etype], etypes[type]);
	}
	np->etype = type;
}

/**********************************************************************/
/*
behavior: type.boolean
behaviorsets: acnbase, acnbase-r2
*/

void
et_boolean_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_boolean, SZ_AF);
}


/**********************************************************************/
/*
behavior: type.signed.integer, type.sint
behaviorsets: acnbase, acnbase-r2
*/

void
et_sint_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_sint, SZ_1 | SZ_2 | SZ_4 | SZ_8);
}


/**********************************************************************/
/*
behavior: type.unsigned.integer, type.uint
behaviorsets: acnbase, acnbase-r2
*/

void
et_uint_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_uint, SZ_1 | SZ_2 | SZ_4 | SZ_8);
}


/**********************************************************************/
/*
behavior: type.float
behaviorsets: acnbase, acnbase-r2
*/

void
et_float_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_float, SZ_4 | SZ_8);
}


/**********************************************************************/
/*
behavior: type.char.UTF-8
behaviorsets: acnbase, acnbase-r2
*/

void
et_UTF8_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_UTF8, SZ_AF);
}


/**********************************************************************/
/*
behavior: type.char.UTF-16
behaviorsets: acnbase, acnbase-r2
*/

void
et_UTF16_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_UTF16, SZ_AF);
}


/**********************************************************************/
/*
behavior: type.char.UTF-32
behaviorsets: acnbase, acnbase-r2
*/

void
et_UTF32_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_UTF32, SZ_AF);
}


/**********************************************************************/
/*
behavior: type.string
behaviorsets: acnbase, acnbase-r2
*/

void
et_string_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_string, SZ_V);
}


/**********************************************************************/
/*
behavior: type.enumeration, type.enum
behaviorsets: acnbase, acnbase-r2
*/

void
et_enum_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_enum, SZ_1 | SZ_2 | SZ_4 | SZ_8);
}


/**********************************************************************/
/*
behavior: type.fixBinob
behaviorsets: acnbase, acnbase-r2
*/

void
et_opaque_fixsize_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_opaque, SZ_AF);
}


/**********************************************************************/
/*
behavior: type.varBinob
behaviorsets: acnbase, acnbase-r2
*/

void
et_opaque_varsize_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_opaque, SZ_V);
}

/**********************************************************************/
/*
behavior: binObject
behaviorsets: acnbase, acnbase-r2
*/

void
et_opaque_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_opaque, SZ_V | SZ_AF);
}


/**********************************************************************/
/*
behavior: UUID
behaviorsets: acnbase, acnbase-r2
*/

void
et_uuid_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_uuid, SZ_16);
}


/**********************************************************************/
/*
behavior: type.bitmap
behaviorsets: acnbase-r2
*/

void
et_bitmap_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	setptype(pp, etype_bitmap, SZ_AF);
}


/**********************************************************************/

void
deviceref_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	/* add_proptask(prop, &do_deviceref, bv); */
}

/**********************************************************************/
/*
behavior: UACN
behaviorsets: acnbase, acnbase-r2
*/
/*
void
persist_string_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	et_string_bva(pp, bv);
	persistent_bva(pp, bv);
}
*/

/**********************************************************************/
/*
behavior: FCTN
behaviorsets: acnbase, acnbase-r2
*/
/*
void
const_string_bva(struct ddlprop_s *pp, const struct bv_s *bv)
{
	et_string_bva(pp, bv);
	constant_bva(pp, bv);
}
*/

/**********************************************************************/
#define DCID_acnbase     "71576eac-e94a-11dc-b664-0017316c497d"  
#define DCID_acnbase_r2  "3e2ca216-b753-11df-90fd-0017316c497d"
#define DCID_acnbaseExt1 "5def7c40-35c1-11df-b42f-0017316c497d"
#define DCID_artnet      "102dbb3e-3120-11df-962e-0017316c497d"
#define DCID_sl          "4ef14fd4-2e8d-11de-876f-0017316c497d"

struct bv_s known_bvs[] = {
	{DCID_acnbase, NULL},
//	{"DMPbinding",               abstract_bva          },
//	{"FCTN",                     const_string_bva      },
//	{"NULL",                     null_bva              },
//	{"UACN",                     persist_string_bva    },
	{"UUID",                     et_uuid_bva           },
//	{"accessClass",              abstract_bva          },
//	{"algorithm",                abstract_bva          },
//	{"atomicLoad",               abstract_bva          },
//	{"beamDiverter",             abstract_bva          },
	{"binObject",                et_opaque_bva         },
//	{"boolean",                  abstract_bva          },
//	{"connectionDependent",      abstract_bva          },
	{"constant",                 constant_bva          },
//	{"cyclicPath",               abstract_bva          },
//	{"date",                     abstract_bva          },
//	{"devSerialNo",              const_string_bva      },
//	{"direction",                abstract_bva          },
//	{"encoding",                 abstract_bva          },
//	{"enumeration",              abstract_bva          },
//	{"hardwareVersion",          const_string_bva      },
//	{"manufacturer",             const_string_bva      },
//	{"maunfacturerURL",          const_string_bva      },
//	{"orientation",              abstract_bva          },
	{"persistent",               persistent_bva        },
//	{"preferredValue.abstract",  abstract_bva          },
//	{"propertyRef",              abstract_bva          },
//	{"publishParam",             abstract_bva          },
//	{"pullBindingMechanism",     abstract_bva          },
//	{"pushBindingMechanism",     abstract_bva          },
//	{"rate",                     abstract_bva          },
//	{"reference",                abstract_bva          },
//	{"scale",                    abstract_bva          },
//	{"softwareVersion",          const_string_bva      },
//	{"streamFilter",             abstract_bva          },
//	{"time",                     abstract_bva          },
	{"type.boolean",             et_boolean_bva        },
	{"type.char.UTF-16",         et_UTF16_bva          },
	{"type.char.UTF-32",         et_UTF32_bva          },
	{"type.char.UTF-8",          et_UTF8_bva           },
	{"type.enum",                et_enum_bva           },
	{"type.enumeration",         et_enum_bva           },
	{"type.fixBinob",            et_opaque_fixsize_bva },
	{"type.float",               et_float_bva          },
//	{"type.floating_point",      abstract_bva          },
	{"type.signed.integer",      et_sint_bva           },
	{"type.sint",                et_sint_bva           },
	{"type.string",              et_string_bva         },
	{"type.uint",                et_uint_bva           },
	{"type.unsigned.integer",    et_uint_bva           },
	{"type.varBinob",            et_opaque_varsize_bva },
//	{"typingPrimitive",          abstract_bva          },
	{"volatile",                 volatile_bva          },

	{DCID_acnbase_r2, NULL},
//	{"DMPbinding",               abstract_bva          },
//	{"FCTN",                     const_string_bva      },
	{"FCTNstring",               et_string_bva         },
//	{"NULL",                     null_bva              },
//	{"UACN",                     persist_string_bva    },
	{"UUID",                     et_uuid_bva           },
//	{"abstractPriority",         abstract_bva          },
//	{"accessClass",              abstract_bva          },
//	{"algorithm",                abstract_bva          },
//	{"atomicLoad",               abstract_bva          },
	{"binObject",                et_opaque_bva         },
//	{"boolean",                  abstract_bva          },
//	{"connectionDependent",      abstract_bva          },
	{"constant",                 constant_bva          },
//	{"cyclicPath",               abstract_bva          },
//	{"date",                     abstract_bva          },
//	{"devSerialNo",              const_string_bva      },
//	{"direction",                abstract_bva          },
//	{"encoding",                 abstract_bva          },
//	{"enumeration",              abstract_bva          },
//	{"hardwareVersion",          const_string_bva      },
//	{"manufacturerURL",          const_string_bva      },
//	{"orientation",              abstract_bva          },
	{"persistent",               persistent_bva        },
//	{"preferredValue.abstract",  abstract_bva          },
//	{"propertyRef",              abstract_bva          },
//	{"publishParam",             abstract_bva          },
//	{"pullBindingMechanism",     abstract_bva          },
//	{"pushBindingMechanism",     abstract_bva          },
//	{"rate",                     abstract_bva          },
//	{"reference",                abstract_bva          },
//	{"scale",                    abstract_bva          },
//	{"softwareVersion",          const_string_bva      },
//	{"time",                     abstract_bva          },
	{"type.bitmap",              et_bitmap_bva         },
	{"type.boolean",             et_boolean_bva        },
	{"type.char.UTF-16",         et_UTF16_bva          },
	{"type.char.UTF-32",         et_UTF32_bva          },
	{"type.char.UTF-8",          et_UTF8_bva           },
	{"type.enum",                et_enum_bva           },
	{"type.enumeration",         et_enum_bva           },
	{"type.fixBinob",            et_opaque_fixsize_bva },
	{"type.float",               et_float_bva          },
//	{"type.floating_point",      abstract_bva          },
	{"type.signed.integer",      et_sint_bva           },
	{"type.sint",                et_sint_bva           },
	{"type.string",              et_string_bva         },
	{"type.uint",                et_uint_bva           },
	{"type.unsigned.integer",    et_uint_bva           },
	{"type.varBinob",            et_opaque_varsize_bva },
//	{"typingPrimitive",          abstract_bva          },
	{"volatile",                 volatile_bva          },

	{DCID_sl, NULL},
//	{"simplifiedLighting",       abstract_bva          },

	{NULL, NULL},
};
