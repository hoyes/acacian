title: DMP Interface

about: Main configuration options

DMP code includes both device and controller code since many 
components will include both. However, compile options 
CONFIG_DMP_DEVICE and CONFIG_DMP_CONTROLLER (both enabled by 
default) allow only one or the other to be built and the unneeded 
code is then omitted.

As with other layers, CONFIG_SINGLE_COMPONENT indicates there is 
guaranteed to be just one statically allocated local component 
(typical of many embedded implementations) and simplifies some of the 
code.

about: API

The DMP API is not yet well developed, but dmp.c provides functions 
which accumulate commands into PDUs, PDUs into blocks and then flush 
the blocks via SDT. This API allows a controller to accumulate 
commands to multiple components within an SDT group before 
transmitting the whole block.

For incoming PDUs DMP decodes commands, resolves the DMP address to an 
internal object or function call provided by the application and 
passes the command and data on. This will be extended as described 
below.

about: Function of the DMP layer

It is the job of the application, not the ACN stack to determine 
which values to send or receive for which properties and in some of 
the simplest applications, the DMP layer may be omitted and simple 
DMP blocks sent to SDT directly. But in most cases, the DMP layer's 
primary role, is to connect the internal device model of the 
application to the property addresses and sizes of the protocol. This 
must be done without placing a straightjacket on the architecture of 
the application.

For outgoing get_property, set_property, subscribe and equivalent 
response messages the DMP layer can translate values sent to 
internal objects into appropriate, legal DMP commands.

For incoming property messages, there is an issue of connecting the 
property address of the message to the necessary internal model 
functionality. For devices with hundreds or thousands of properties 
which are distributed sparsely across a huge address space, 
potentially in multi-dimensional arrays, this job is difficult and 
needs to be done very quickly and efficiently.

about: Property mapping

This implementation aims for a common format of tables for handling 
proterty maps of both local and remote components. In both cases, it 
is expected that these tables must be generated from the DDL 
description of the device - using the DDL to generate tables for 
remote devices is the only extensible way to work. Doing so for local 
devices helps to ensure that the local device functions as it's DDL 
says it does - at least in terms of its basic property map.

Whilst property maps for both local and remote components are 
generated from DDL, local component maps can usually be generated 
once at compile time and built in to the code. Changing the DDL and 
re-building the code from it, is then the way to make any changes 
which would affect the description. In contrast, property maps for 
remote components need to be geenrated on the fly (except in some 
special-purpose dedicated controllers) and tools are provided to do 
this - see doc/DDL.txt



about: Format and Strategy for finding properties

On receipt of a property message (and this means most DMP messages), 
the property address must be mapped onto the internal functionality 
for that property. In a device, this probably means making a local 
function call to find the property's value or to initiate the action 
implied by setting the property. In a controller, this means mapping 
the received value or message into the specific remote device instance 
and property within that instance that the controller uses to do its 
work.

To perform this operation the code needs an address to object mapping 
which needs to work fast.

The simplest and fastest method is direct mapping using the property 
address as an array address. For a device with a limited number of 
properties packed closely within the address space, this is ideal. For 
devices, where a single property map linking to internal functionality 
can be generated at compile time this may be the best solution. The 
stylesheet propmap.xsl generates such an array (as C cource code) from 
a device description.

However direct mapping does not generalize and is not suitable for 
controllers which have no control over the DDL for the devices they 
encounter.

A further complication is introduced by the fact that both DDL and DMP 
can express stepwise iteration through the address space with complete 
freedom of starting point, step size and address count. This is 
invaluable for large arrays but complicates matters.

about: Algorithm for address search

The parser builds a single table (a 1 dimensional array) in which 
each each entry E defines a region within the space by a low address 
and a high address E_lo and E_hi (inclusive values). The array 
entries are non-overlapping and sorted in address order. Thus a 
straightforward binary search identifies whether an arbitrary 
address falls within one of these entries. If no entry is found then 
the address is not within the device.

Each single property in the device has a corresponding entry in this 
table for which both the low address and high address are the same.

An array property likewise may form a single entry in which the low 
and high addresses are the extents of the array and if the array is 
packed (occupies every address within its range) it forms a single, 
complete entry. However, array properties may be sparse: if the 
increment of the array - or the smallest increment for 
multidimensional arrays - is greater than one the array contains 
holes. Furthermore, these holes may legitimately be occupied by 
other properties. For example, it is common for arrays to be 
interleaved and this interleaving can extend to multiple 
multidimensioned arrays.

Thus, having found that an address falls within the extents of an 
array, it may need further testing to find whether it is actually a 
member, or whether it falls within a hole, and in the case of 
interleaved arrays it may need testing for membership of more than 
one array.

To handle these cases, each entry in the address table contains a 
test counter ntests. When an address falls within the range defined 
by the entry, ntests indicates how many array properties may overlap 
in that region and need to be tested for membership.

If ntests == 0 then it means that the address region has no holes 
and all its address(s) unambiguously belong to a single property so 
no further tests are needed and we have found the propery. This is 
always the case for singular properties where E_lo and E_hi are the 
same. It is also the case for packed array properties which occupy 
every address within their range (For example a single dimensional 
array with an increment of 1).

If ntests == 1 then there is only one property occupying this region 
but its increments are such that it does not occupy every address so 
a further test is required to establish membership.

If ntests > 1 then we have interleaving and must test for membership 
of multiple property ranges.

If an entry is found then it leads to one or more property addresses 
which need to be further tested. Testing whether the address matches 
a property proceeds as follows:

If E_lo = E_hi then we have a single property which must match.

Otherwise we have a range which includes one or more array 
properties and the Entry identifies a list of the properties to be 
tested. In many cases there will be just one array property in the 
list, but where overlapping arrays occur, it may be necessary to 
test multiple properties. Furthermore, with multi-dimensional arrays 
the test is not trivial. More on testing below.

In generating the table, there is scope for different compromises 
over the granularity with which the table is generated. Consider two 
overlapping arrays P and Q. Using the notation given in the DMP spec 
to represent an address {base, inc, count}:
P = {100, 10, 5}   Q = {125, 10, 5} giving in order:
P[0] = 100
P[1] = 110
P[2] = 120
Q[0] = 125
P[3] = 130
Q[1] = 135
P[4] = 140
Q[2] = 145
Q[3] = 155
Q[4] = 165

We have the choice here of making a single entry:
1. from 100 to 165 - test for P and Q

or we can create three entries:
1. from 100 to 120 - test for P
2. from 125 to 140 - test for P and Q
3. from 145 to 165 test for Q

The second strategy is usually preferred as the binary search 
through the whole space can be optimised as a fast procedure whilst 
iterating through tests for array membership is onerous. However, if 
space is at a premium, or in certain worst case conditions, the 
former strategy may be preferable. However, this choice of strategy 
is made in building the search table. The process of testing a 
property for membership of the device is the same in both cases: the 
address leads to a list of zero or more properties to be tested for 
a match and those properties must be tested in turn.

Tests for property match.
------------------------
Terms.
-----
The address we are testing for match with the property is A

A property has an arbitrary number N of dimensions dI for 0 <= I <= N we
call these d0, d1 .. dI .. dN each of 
which is specified by an increment i0 .. iI .. iN and a count. For the 
algorithms here we will use the range limit instead of the count. r (= 
count - 1) thus the maximum inclusive value of property address P due to 
dimension I is PmaxI = Pbase + rI * iI.

A generic member of the array P is Px where:

  (1)  Px = Pbase + x0 * i0 + x1 * i1 + ... + xN *iN

For N = 0 we have a single point property and the test is trivial:

  (2)  A == Pbase (or A - Pbase == 0)

For N = 1 we have a linear array, but if increment i0 > 1 then there 
are holes so we need to know whether (A - Pbase) is an integer 
multiple of i0. The simplest test is to use the modulus:

  (3) (A - Pbase) % i0 == 0

For higher dimensions testing becomes more complex. The range of P 
is given by:

  (4)  Pbase <= P <= Pbase + i0 * r0 + i1 * r1 + ... + iN * rN

Now recalling (1) we want to test A == Px ? but we do not know the 
values for x0, x1 etc. Iterating through all x0, x1, x2 etc is not
practicable for large arrays. In most cases increments and counts 
are chosen such that there is no overlap between dimensions (in a 
two dimensional case this is the same as saying that one row does 
not overlap with the next or previous). However there is no 
guarantee that this isn't the case. What we do know though provides 
limits on x0..xN.

First by subtracting Pbase from all calculations we can simplify so:

  (5)  Ao = A - Pbase

Assume A is in P then for some valid set of x0..xN:

  (6)  Ao == x0 * i0 + x1 * i1 + ... + xN * iN

Solving for an individual xI

  (7)  xI * iI == Ao - (x0 * i0 + x1 * i1 + .. [miss out xI * iI] .. + xN * iN)

The largest value possible of xI for a given Ao is when all other x 
are zero and the bracketed term in (7) becomes zero:

  (8)  xI_largest == Ao/iI

but we know that xI <= rI so for a given Ao and for each dimension 
the top limit for xI we will call tI:

  (9)  tI = minimum(rI, Ao/iI)

We can now calculate tI for each dimension. Now using (7) again what 
is the smallest for xI? this will occur when all other x are at 
their maximum, but we have now calculated those maxima t0..tN. So:

  (10)  xI_smallest = (Ao - (t0 * i0 + .. [miss out tI * iI] .. + tN * iN))
                      -------------------------------------------------
                                       iI

but we also know that xI >= 0 so this gives us the bottom limit on 
xI which we call bI

  (14)  bI = maximum(0, xI_smallest)

We have now established for a test value A, a restricted range of 
indexes which we should test for each dimension to see whether A is 
in P.
We can choose one arbitrary dimension, then iterating over all 
possible values from bI to tI for all the other dimensions, 
rearranging (7) and using the modulus test for integral factors our 
test becomes:

  (15) (Ao - (x0 * i0 .. [miss Ith term] .. xN * iN)) % iI == 0

repeated for all possible xI: bI <= xI <= tI

The process of calculating bI and tI for each dimension may seem onerous
but in realistic arrays it hugely reduces the search space. However, 
it is possible to optimize further:

If the array is non-overlapping, the value of bI and tI come out  
identical for the outermost dimension (the one with the largest 
increment iI) incdicating that this dimension need not be iterated 
at all. This must be so because in a non-overlapping array there is 
only one possible span of the lesser dimensions within which Ao 
could occur. Having established this value, we now know that we can 
fix it and update the calculations for the remaining dimensions but 
with the fixed value for the outermost. If the array is overlapping, 
we may find the outermost dimension does not reduce to a single span 
to be searched, but nevertheless, substituting the values for tI and 
bI into the equations above reduces the range to search within other 
dimensions further.

Generalising this principle, if the dimensions are sorted so they 
are tested in order from outermost (largest increment) to innermost 
(smallest increment), instead of the declaration order which is 
arbitrary, the search reduces to the smallest possible range.

