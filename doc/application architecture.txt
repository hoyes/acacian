title: Acacian Application Architecture

This document outlines the top-level approach to application 
architecture in Acacian and says what the Acacian implementation handles and 
what is left to the application. Most of this document assumes a 
full DMP application although there are notes on simplification and 
some discussion of E1.31 only implementation.

Whilst there is skeleton of most of the code here, as of March 2011, 
some of this documentation is aspirational. However anyone extending 
or building on Acacian is very strongly urged to heed these guidelines so 
as to ensure an efficient and consistent implementation.

topic: Layers and modules

Acacian implements the following layers and modules, roughly top down:

DDL - Compile-time (for devices) and dynamic run-time parsing and 
	generation of tables for DMP.

DMP - Registration of devices and descriptions, handling of connections, 
	resolution of property addresses to internal functions and vice versa.

SDT - Session management, reliable and unreliable PDU transmit and 
	receive, buffering and re-sending, notification of online status.

E1.31 - Receiver code, tracks multiple source-universes 
	according to the specification. [note: RLP and other support code has 
	changed considerably since E1.31 was last built and tested].

Root layer - Wrapping outgoing packets, de-multiplexing incoming 
	packets to SDT and E1.31.

Socket layer - Handles the OS and stack dependencies associated with 
	Root layer traffic, including multicast subscribe and unsubscribe.

Timers and events - Maintains a queue of future events and 
	interfaces to the OS timing services to ensure that these events are 
	handled in timely and ordered manner.

topic: Compiler and Platform

This code has currently only been built using GCC and GNU Make on 
Linux platforms - both desktop and small embedded. It assumes ISO 
C99 compliance. Porting to other compilers and platforms is on the 
TODO list!

No Makefile is provided because in testing it has been found more 
convenient to integrate the sources into the build process for the 
main application. Compiling the source with GCC is relatively 
straightforward.

topic: Component Handling

Acacian makes a fundamental distinction between Local components and 
Remote components. In particular it needs different information 
relating to them and uses different structures to deal with them. In 
many implementations, there is just one local component which is 
tighly bound to Acacian and may be statically defined. However, some 
applications may implement multiple local components on the same 
Acacian instance and the code becomes more complex because 
one local component may need to talk to another. In this situation, 
the same component may appear as both a local component and a remote 
one.

To avoid unnecessary duplication, pointers and small structures, the 
main structures for both local and remote components contain data for 
multiple layers. However, much of this data is intended for internal 
use within the relevant layer only and should not be touched by 
application code.

topic: UUID tracking

Connecting component CIDs as specified in incoming packets, dicovery 
etc. to their internal structures needs to be done very rapidly and 
efficiently. Searching a linear list is not sensible. Code for two 
optimized methods is provided - one relying on hash tables, the 
other on a dynamically built radix search tree ("patricia tree"). 
The latter is the preferred option in most cases though some 
realistic profiling tests would be useful. This code is contained in 
uuid.c and is used for storing and tracking almost eny entity 
identified by UUID including device classes (DCIDs), behaviorsets 
and languages.

topic: Discovery

Acacian does *not* implement discovery itself â€“ 
this is a separate problem which is well addressed by openSLP or 
other SLP implementations. Acacian does however provide some code to 
generate and parse SLP URLs and attributes which are conformant with 
EPI-19.

The generic UUID and component handling code in Acacian can also be 
used by the application to help manage discovered components. In 
order to connect to those components SDT only needs to be provided 
with the CID and adhoc address for the component, whilst DMP needs 
appropriate property maps (see doc/DMP.txt).

Unfortunately, the SDT protocol is not clean with respect to 
discovery. It confuses the issue by declaring expiry times and adhoc 
addresses within packets, and requires the implementation to support 
adhoc queries on almost any incoming socket, many of which could 
otherwise be optimised for a very narrow range of commands and 
sources. This implementation handles this poor situation notifying 
the application of this information, but does not attempt to retain 
or track addresses and expiry times learrned in this way - that is 
the job of the discovery subsystem.

topic: Memory Allocation

ACN code uses its own memory allocation calls defined in "acnmem.h" 
and "acnmem.c". As currently defined these allocate larger blocks 
using malloc and divide them up into units of fixed sizes. Blocks 
which are freed are not returned to the system but are retained for 
future use.

Changes to memory method allocation should be made by 
revising the calls in acnmem.h and if necessary acnmem.c - a simple 
set of macros in acnmem.h could wrap direct calls to POSIX or similar 
malloc and allow compialtion without acnmem.c at all. Alternatively, 
the current implementation can be changed with very little 
effort to assign all memory from fixed pre-alocated blocks - 
suitable for many small embedded systems.

The "feature" that the size of block is specified not only in the 
alloc() call, but also in the free() call, allows this system to 
operate with zero space overhead for allocated blocks. There are no 
accl to realloc() blocks and no dependence on virtual memory.

Maintenance of tables of fixed block sizes lends itself to 
experimental profiling of the actual memory usage and of the sizes 
required - block sizes cannot be accurately predicted in the general 
case because the both size and alignment requirements of individual 
structures varies with compiler and platform.

topic: Timers, Threads, Queues and Polling

There is an inner poll loop and event queue within the socket layer 
and timer code. This loop is single-threaded and handles virtually 
the whole of the receive and timing code up to and including SDT. SDT 
places any wrappers which contain PDU blocks for higher layers into a 
receive queue. If built with CONFIG_RX_AUTOCALL true, the code will 
automatically read and handle each wrapper (by calling the registered 
higher layer callback functions) once it has completed SDT layer 
processing. However, depending on the application this may not work 
well because it holds up processing of any new incoming messages until 
the last one has been fully handled. If CONFIG_RX_AUTOCALL, ACN must 
be polled periodically to handle any received packets in the queue.

topic: Layering, Initialization, Registration and Callbacks

Acacian attempts to ensure that each layer needs only to interact with 
other layers with which it has direct contact, and this applies to the 
application as well. One layer initiates processing by registering 
with the layer below - supplying callbacks to handle incoming data 
or other events (such as connection making or breaking). It is the job 
of that lower layer to make corresponding calls or registration to the 
next layer down as necessary. For example a device application using 
DMP registers with the DMP layer - it may need minimal interaction 
with SDT (e.g. to handle connection-broken notifications), but should 
not need to initialize or even consider the root layer or timing 
services.

topic: Tailoring and Optimizing for specific applications.

Acacian provides many compile-time switches to customize your build - see 
"doc/build options.txt" for overview and acncfg.h for full details.
