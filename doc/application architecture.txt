ea-ACN Application Architecture
--
This document outlines the top-level approach to application 
architecture in ea-ACN and says what the ea-ACN implementation handles and 
what is left to the application. Most of this document assumes a 
full DMP application although there are notes on simplification and 
some discussion of E1.31 only implementation.

Whilst there is skeleton of most of the code here, as of March 2011, 
some of this documentation is aspirational. However anyone extending 
or building on ea-ACN is very strongly urged to heed these guidelines so 
as to ensure an efficient and consistent implementation.

Layers and modules
--
ea-ACN implements the following layers and modules - roughly top down:

DDL:
  Static (for devices) and dynamic parsing and generation of tables 
  for DMP.

DMP:
  Registration of devices and descriptions, handling of connections, 
  resolution of property addresses tointernal functions and vice versa.

SDT:
  Session management, reliable and unreliable PDU transmit and 
  receive, buffering and re-sending, notification of online status.

E1.31:
  Receiver code tested and working, tracks multiple source-universes 
  according to the specification. but RLP and other support code has 
  since changed.

Root layer:
  Wrapping outgoing packets, de-multiplexing incoming packets to SDT 
  and E1.31.

Timers:
  Maintains a queue of future events and interfaces to the OS timing 
  services to ensure that these events are handled in timely and 
  ordered manner.

Socket layer:
  Handles the OS and stack dependencies associated with Root layer 
  traffic, including multicast subscribe and unsubscribe.

Compiler and Platform
--
This code has currently only been built using GCC and GNU Make on 
Linux platforms - both desktop and small embedded. It assumes ISO 
C99 compliance. Porting to other compilers and platforms is on the 
TODO list!

No Makefile is provided because in testing it has been found more 
convenient to integrate the sources into the build process for the 
main application. Compiling the siurce with GCC is relatively 
straightforward.

Discovery
--
ea-ACN provides minimal hooks for discover but does NOT perform 
discovery itself - this is a separate problem which is well 
addressed by openSLP or other SLP implementations. It is up to the 
application to interface to SLP to discover the components of 
interest to it. SLP provides the necessary lifetime and expiry 
functionality, re-advertisement in case of change and so on. In 
order to connect to those components SDT only needs to be provided 
with the CID and adhoc address for the component, whilst DMP needs 
appropriate property maps (see doc/DMP.txt).

Unfortunately, the SDT protocol is not clean with respect to 
discovery. It confuses the issue by declaring expiry times and adhoc 
addresses within packets, and requires the implementation to support 
adhoc queries on almost any incoming socket, many of which could 
oitherwise be optimised for a very narrow range of commands and 
sources. This implementation handles this poor situation notifying 
the application of this information, but does not attempt to retain 
or track addresses and expiry times learrned in this way - that is 
the job of the discovery subsystem.

Component Handling
--
ea-ACN makes a fundamental distinction between Local components, 
Remote components. In particular it needs different information 
relating to them and uses different structures to deal with them. In 
many implementations, there is just one local component which is 
tighly bound to ea-ACN and may be statically defined. However, some 
applications may implement multiple local components on the same 
ea-ACN instance and in this case the code becomes more complex because 
one local component may need to talk to another. In this situation, 
the same component may appear as both a local component and a remote 
one.

To avoid unnecessary duplication, pointers and small structures, the 
main structures for both local and remote components contain data for 
multiple layers. However, much of this data is intended for internal 
use within the relevant layer only and should not be touched by 
application code. To extend this principal into the application 
though, there is space within the component structure for an 
application layer structure which may be used to store whatever data 
the application wishes.

Connecting component CIDs as specified in incoming packets, dicovery 
etc. to their internal structures needs to be done very rapidly and 
efficiently. Searching a linear list is not sensible. Code for two 
optimized methods is provided - one relying on hash tables, the 
other on a dynamically built radix search tree ("patricia tree"). 
The latter is the preferred option in most cases though some 
realistic profiling tests would be useful. This code is contained in 
uuid.c and is used for storing and tracking almost eny entity 
identified by UUID including device classes (DCIDs), behaviorsets 
and languages.

Memory Allocation
--
ACN code uses its own memory allocation calls defined in "acnmem.h" 
and "acnmem.c". As currently defined these allocate larger blocks 
using malloc and divide them up into units of fixed sizes. Blocks 
which are freed are not returned to the system but are retained for 
future use.

Changes to memory method allocation should be made by 
revising the calls in acnmem.h and if necessary acnmem.c - a simple 
set of macros in acnmem.h could wrap direct calls to POSIX or similar 
malloc and allow compialtion without acnmem.c at all. Alternatively, 
the current implementation can be changed with very little 
effort to assign all memory from fixed pre-alocated blocks - 
suitable for many small embedded systems.

The "feature" that the size of block is specified not only in the 
alloc() call, but also in the free() call, allows this system to 
operate with zero space overhead for allocated blocks. There are no 
accl to realloc() blocks and no dependence on virtual memory.

Maintenance of tables of fixed block sizes lends itself to 
experimental profiling of the actual memory usage and of the sizes 
required - block sizes cannot be accurately predicted in the general 
case because the both size and alignment requirements of individual 
structures varies with compiler and platform.

Timers, Threads, Queues and Polling
--
There is an inner poll loop and event queue within the socket layer 
and timer code. This loop is single-threaded and handles virtually 
the whole of the receive and timing code up to and including SDT. SDT 
places any wrappers which contain PDU blocks for higher layers into a 
receive queue. If built with CONFIG_RX_AUTOCALL true, the code will 
automatically read and handle each wrapper (by calling the registered 
higher layer callback functions) once it has completed SDT layer 
processing. However, depending on the application this may not work 
well because it holds up processing of any new incoming messages until 
the last one has been fully handled. If CONFIG_RX_AUTOCALL, ACN must 
be polled periodically to handle any received packets in the queue.

Layering, Initialization, Registration and Callbacks
--
ea-ACN attempts to ensure that each layer needs only to interact with 
other layers with which it has direct contact, and this applies to the 
application as well. One layer initiates processing by registering 
with the layer below - supplying callbacks to handle incoming data 
or other events (such as connection making or breaking). It is the job 
of that lower layer to make corresponding calls or registration to the 
next layer down as necessary. For example a device application using 
DMP registers with the DMP layer - it may need minimal interaction 
with SDT (e.g. to handle connection-broken notifications), but should 
not need to initialize or even consider the root layer or timing 
services.

Tailoring and Optimizing for specific applications.
--
ea-ACN provides many compile-time switches to customize your build - see 
"doc/build options.txt" for overview and acncfg.h for full details.
