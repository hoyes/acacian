DDL interface

For both devices and controllers, the DDL description is used to 
generate a map of property addresses which is used by DMP.

Devices
--
For building a simple device, the property map is a static part of the 
code of the device itself, and the device has no need for DDL (except 
to serve it up as opaque files as required by epi11.

The device DDL forms part of the build, then if extra functions or 
properties need to be added, this is done by modifying the DDL and so 
ensures that the description should match the actual properties.

The property map in a device relates incoming addresses to a handler 
routine (provided the application code) which is called by DMP when the 
corresponding property is addressed. The handler routine is passed the 
command and data, the property address and a reference pointer which 
can be used for any purpose the application requires.

DDL extension
--
To allow the application layer handler function to be specified within 
the DDL itself, an expension element has been defined. This is the 
element <ea:propext name="" value=""/> which is in the namespace:
"http://www.engarts.com/namespace/2011/ddlx" This can be added within 
any <protocol> element and allows a generic specification of a field 
name and value for incorporation into the property map. The use of a 
namespace allows this extension element to be added to descriptions 
within the rules of DDLv1.1 and compliant parsers should ignore it 
(unless they are programmed to use it).

Use of XSLT
--
For translating DDL as part of the build process, XSLT is an ideal 
language. It allows a stylesheet to be written which generates C 
source from the DDL, which is then compiled into the code.

The stylesheet propmap.xsl does this for simple devices, producing a 
directly mapped property table. A modification of this 
stylesheet is intended which will generate the more complex tables for 
the generic property mapping strategy in doc/DMP.txt

Dynamic Parsing
--
All but the most restricted controllers need dynamic interpretation of 
DDL according to the devices they encounter on the network. The Expat 
parser has been found to be a suitable lightweight parser with a 
non-restrictive open-source license and written in C. A DDL parser has 
been built around this in parseddl.c. This currently has the form of an 
application program but this is only a thin wrapper around a generic 
parsedevx() function.

parsedevx() is passed the root UUID of a device description (root 
DCID). It fetches the DDL, and builds a fairly simple in-memory 
property tree structure as it traverses the description. It fetches 
any included devices as it goes and builds them into the same tree.

Strategy for handling DDL
--
The strategy used in this implementation is as follows:

1. The application finds devices on the network via SLP/discovery 
and discovers their root DCID.

2. It passes the DCID to ea-ACN parser code which can take 2 possible 
actions:

  a. The DCID is new to this session - the DCID is passed to a 
  resolver for retrieval. Once it has the DDL it is parsed to generate 
  a property tree.

  b. The DCID is known and has already been parsed. The generic UUID 
  management code can very rapidly retrieve this structure given the 
  DCID. The structure retrieved is either the complete property tree 
  or the property map (see below) which is returned to the 
  application.

3. Parsing the DDL generates a property tree structure which contains 
all the necessary information about property addresses, sizes, access 
permissions and so on, as well as behaviors, labels etc. as needed.

4. The property tree is then traversed in memory to generate a flat 
property map array matching the address mapping strategy of DMP (see 
doc/DMP.txt).

5. Having extracted the property map, the tree structure is no longer 
needed by ea-ACN code. However, the tree contains the full hierarchical 
information of the description inclduing behaviors, immediate values 
and with all subdevices included in a compact, in-memory format. 
Depending on needs, this tree can either be passed to the 
application, or discarded and its memory freed and the property-map 
alone passed on.

If using the property tree, the application may either build it into 
its own structures as-is and add such information as suits it; or it 
may traverse the tree to extract the information it needs to build its 
own structures, then discard the tree.

Handling behaviors
--
Behaviors are only useful to an application 
which has some support for them. On first parse of the DDL, the 
parser needs a table of behaviors supported by the application. Each 
behavior encountered is then matched against this table and a link 
from the property tree to the table is generated if a match is 
found. Optionally unrecognized behaviors can be left in the property 
tree as  simple UUID/name values for later consideration.

The nature of the object associated with each behavior is largely 
application dependent, but it is expected that callbacks will be 
provided for calling, either at instantiation time (each time a device 
with the relevant DCID is added), or on receipt of a corresponding 
get/set/event etc message, or both.

Handling Strings
--
String handling is very user interface dependent and little has been 
done at this time. However, again the generic UUID tracking and 
management code provides a means to access languagesets flexibly by 
UUID.

Parsing DDL to generate tables of strings keyed by name and language 
is relatively simple.

DDL cach, files and directory sructure
--
At present, parseddl.c has a hard-coded location where it looks for 
DDL modules by name. This needs to be developed into a resolver which 
finds DDL files in cache locations (when possible) and retrieves them 
using TFTP when no cache copy is found.

