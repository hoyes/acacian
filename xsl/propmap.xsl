<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE stylesheet [
<!ENTITY tb "&#x9;">
<!ENTITY nl "&#xa;">
]>
<!-- vi: set sw=3 ts=3: -->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:ea="http://www.engarts.com/namespace/2011/ddlx"
	xmlns:ddl="http://www.esta.org/acn/namespace/ddl/2008/"
	xmlns:str="http://exslt.org/strings"
>
<!--
-->
	<xsl:output method="text" encoding="US-ASCII"/>

	<xsl:param name="devaddr" select="0"/>
	<xsl:param name="verbose" select="false()"/>
	<xsl:key name="submod" match="UUIDname/@UUID" use="../@name"/>

<!--
########################################################################
	Root node
########################################################################
-->
<xsl:template match="/">
<!--
construct variables for major statistics
-->
<xsl:variable name="sizestr">
	<xsl:apply-templates select="//device" mode="sizes"/>
</xsl:variable>

<xsl:variable name="maxsize">
	<xsl:call-template name="stringop">
		<xsl:with-param name="op" select="'max'"/>
		<xsl:with-param name="numstr" select="$sizestr"/>
	</xsl:call-template>
</xsl:variable>

<xsl:variable name="minsize">
	<xsl:call-template name="stringop">
		<xsl:with-param name="op" select="'min'"/>
		<xsl:with-param name="numstr" select="$sizestr"/>
	</xsl:call-template>
</xsl:variable>

<xsl:variable name="locstr">
	<xsl:apply-templates select="//device" mode="locs"/>
</xsl:variable>

<xsl:variable name="maxloc">
	<xsl:call-template name="stringop">
		<xsl:with-param name="op" select="'max'"/>
		<xsl:with-param name="numstr" select="$locstr"/>
	</xsl:call-template>
</xsl:variable>

<xsl:variable name="minloc">
	<xsl:call-template name="stringop">
		<xsl:with-param name="op" select="'min'"/>
		<xsl:with-param name="numstr" select="$locstr"/>
	</xsl:call-template>
</xsl:variable>

<xsl:variable name="countstr">
	<xsl:apply-templates select="//device" mode="count"/>
</xsl:variable>

<xsl:variable name="pcount">
	<xsl:call-template name="stringop">
		<xsl:with-param name="op" select="'sum'"/>
		<xsl:with-param name="numstr" select="$countstr"/>
	</xsl:call-template>
</xsl:variable>

<xsl:variable name="modcname"
	select="translate(.//device/UUIDname[@UUID = ../@UUID]/@name, '.-:', '___')"/>

<xsl:text
/>/***********************************************************************

                               WARNING
    This file is automatically generated from DDL device description

                         Do not edit manually.

***********************************************************************/
#include "acncommon.h"
#include "dmpops.h"
#include "propmap.h"

#if <xsl:value-of select="$maxsize"/> > MAX_PROP_SIZE
#error Maximum property size exceeds limit
#endif

struct propmap_s propmap_<xsl:value-of select="$modcname"/> = {
	.nprops = <xsl:value-of select="$pcount"/>,
	.maxaddr = <xsl:value-of select="$maxloc"/>,
	.minaddr = <xsl:value-of select="$minloc"/>,
	.maxsize = <xsl:value-of select="$maxsize"/>,
	.minsize = <xsl:value-of select="$minsize"/>,
	.map = {
<xsl:text/>

	<xsl:apply-templates select="//device">
		<xsl:with-param name="base" select="$devaddr"/>
		<xsl:with-param name="nestlevel" select="0"/>
	</xsl:apply-templates>

<xsl:text
/>	}
};
<xsl:text/>

</xsl:template>

<!--
########################################################################
	Device
########################################################################
-->
<xsl:template match="device">
	<xsl:param name="base" select="0"/>
	<xsl:param name="refsuff" select="''"/>
	<xsl:param name="nestlevel" select="0"/>

<xsl:text
/>/***********************************************************************
<xsl:choose>
	<xsl:when test="$nestlevel = 0">
<xsl:text/>                            ROOT DEVICE<xsl:text/>
	</xsl:when>
	<xsl:otherwise>
<xsl:text/>                       Level <xsl:value-of select="$nestlevel"/> SUB-DEVICE<xsl:text/>
	</xsl:otherwise>
</xsl:choose>
        label: "<xsl:value-of select="concat(label/@key, label)"/>"<xsl:text/>
 base address: <xsl:value-of select="$base"/>
<xsl:if test="@xml:id">
           ID: <xsl:value-of select="@xml:id"/>
</xsl:if>
         UUID: <xsl:value-of select="@UUID"/>
***********************************************************************/
<xsl:text/>

	<xsl:apply-templates select=".//propref_DMP">
		<xsl:sort data-type="number"
			select="sum(../../ancestor::property/protocol/childrule_DMP/@loc) + @loc"/>
		<xsl:with-param name="base" select="$base"/>
		<xsl:with-param name="refsuff" select="$refsuff"/>
		<xsl:with-param name="nestlevel" select="$nestlevel"/>
	</xsl:apply-templates>

	<xsl:apply-templates select=".//includedev">
		<xsl:sort data-type="number"
			select="sum(ancestor-or-self::*/protocol/childrule_DMP/@loc)"/>
		<xsl:with-param name="base" select="$base"/>
		<xsl:with-param name="refsuff" select="$refsuff"/>
		<xsl:with-param name="nestlevel" select="$nestlevel"/>
	</xsl:apply-templates>

</xsl:template>

<!--
########################################################################
	Includedev
########################################################################
-->
<xsl:template match="includedev">
	<xsl:param name="base" select="0"/>
	<xsl:param name="refsuff" select="''"/>
	<xsl:param name="nestlevel" select="0"/>

	<xsl:variable name="subbase"
		select="sum(ancestor-or-self::*/protocol/childrule_DMP/@loc) + $base"/>
	<xsl:variable name="subsuffix"
		select="concat(
					str:concat(ancestor-or-self::*/protocol/ea:propext[@name='refsuffix']/@value)
					, $refsuff)"/>

	<xsl:if test="$verbose">
		<xsl:message>
			<xsl:text/>Including device <xsl:value-of select="@UUID"/>
			<xsl:text/> at base address <xsl:value-of select="$subbase"/>
			<xsl:text/> with suffix "<xsl:value-of select="$subsuffix"/>"<xsl:text/>
			<xsl:text>&nl;</xsl:text>
		</xsl:message>
	</xsl:if>

	<xsl:apply-templates
			select="document(concat('DDL:', key('submod', @UUID)))/DDL/device">
		<xsl:with-param name="base" select="$subbase"/>
		<xsl:with-param name="refsuff" select="$subsuffix"/>
		<xsl:with-param name="nestlevel" select="$nestlevel + 1"/>
	</xsl:apply-templates>
</xsl:template>

<!--
########################################################################
	propref_DMP
########################################################################
-->
<xsl:template match="propref_DMP">
<xsl:param name="base" select="0"/>
<xsl:param name="refsuff" select="''"/>
<xsl:param name="nestlevel" select="0"/>

<xsl:variable name="propaddr"
	select="sum(../../ancestor::property/protocol/childrule_DMP/@loc) + $base + @loc"/>

<xsl:variable name="rflag">
	<xsl:if test="@read = 'true'"> | PROP_READ</xsl:if>
</xsl:variable>
<xsl:variable name="wflag">
	<xsl:if test="@write = 'true'"> | PROP_WRITE</xsl:if>
</xsl:variable>
<xsl:variable name="evflag">
	<xsl:if test="@event = 'true'"> | PROP_EVENT</xsl:if>
</xsl:variable>
<xsl:variable name="varflag">
	<xsl:if test="@varsize = 'true'"> | PROP_VSIZE</xsl:if>
</xsl:variable>

<xsl:variable name="sep">
	<xsl:text>,
			</xsl:text>
</xsl:variable>

<xsl:variable name="getfn">
	<xsl:if test="../ea:propext[@name='getfn']">
		<xsl:value-of select="concat($sep, '.getfn = ', ../ea:propext[@name='getfn']/@value)"/>
	</xsl:if>
</xsl:variable>
<xsl:variable name="setfn">
	<xsl:if test="../ea:propext[@name='setfn']">
		<xsl:value-of select="concat($sep, '.setfn = ', ../ea:propext[@name='setfn']/@value)"/>
	</xsl:if>
</xsl:variable>
<xsl:variable name="subsfn">
	<xsl:if test="../ea:propext[@name='subsfn']">
		<xsl:value-of select="concat($sep, '.subsfn = ', ../ea:propext[@name='subsfn']/@value)"/>
	</xsl:if>
</xsl:variable>
<xsl:variable name="fnref">
	<xsl:if test="../ea:propext[@name='fnref']">
		<xsl:value-of select="concat($sep, '.fnref = ',
								../ea:propext[@name='fnref']/@value,
								$refsuff,
								str:concat(ancestor::property/protocol/ea:propext[@name='refsuffix']/@value))"/>
	</xsl:if>
</xsl:variable>

<xsl:if test="string($rflag) and not(string($getfn))">
	<xsl:message terminate="no">warning: Property <xsl:value-of select="$propaddr"/> has read attribute but no get function</xsl:message>
</xsl:if>
<xsl:if test="string($wflag) and not(string($setfn))">
	<xsl:message terminate="no">warning: Property <xsl:value-of select="$propaddr"/> has write attribute but no set function</xsl:message>
</xsl:if>
<xsl:if test="string($evflag) and not(string($subsfn))">
	<xsl:message terminate="no">warning: Property <xsl:value-of select="$propaddr"/> has event attribute but no subscribe function</xsl:message>
</xsl:if>
<xsl:if test="not($rflag) and $getfn">
	<xsl:message terminate="no">warning: Property <xsl:value-of select="$propaddr"/> has get function but read is false</xsl:message>
</xsl:if>
<xsl:if test="not($wflag) and $setfn">
	<xsl:message terminate="no">warning: Property <xsl:value-of select="$propaddr"/> has set function but write is false</xsl:message>
</xsl:if>
<xsl:if test="not($evflag) and $subsfn">
	<xsl:message terminate="no">warning: Property <xsl:value-of select="$propaddr"/> has subscribe function but event is false</xsl:message>
</xsl:if>


<xsl:text/>/*
property "<xsl:text/>
	<xsl:apply-templates select="../../label" mode="labelLookup"/>
	<xsl:text/>" at address <xsl:value-of select="$propaddr"/>
behaviors: <xsl:text/>
	<xsl:for-each select="../../behavior">
		<xsl:sort select="@set"/>
		<xsl:sort select="@name"/>
		<xsl:if test="not(position() = 1)">, </xsl:if>
		<xsl:value-of select="@name"/>
   </xsl:for-each>
<xsl:text/>
*/
		[<xsl:value-of select="$propaddr"/>] = {
			.flags = PROP_VALID<xsl:text/>
			<xsl:value-of select="$rflag"/>
			<xsl:value-of select="$wflag"/>
			<xsl:value-of select="$evflag"/>
			<xsl:value-of select="$varflag"/>,
			.size = <xsl:value-of select="@size"/>
			<xsl:value-of select="$getfn"/>
			<xsl:value-of select="$setfn"/>
			<xsl:value-of select="$subsfn"/>
			<xsl:value-of select="$fnref"/>
		},
<xsl:text/>
</xsl:template>

<!--
########################################################################
	Label
########################################################################
-->
<xsl:template match="label" mode="labelLookup">

<xsl:choose>
<!--
	<xsl:when test="$string">
		<xsl:value-of select="$string"/>
	</xsl:when>
-->
	<xsl:when test="@key">
		<xsl:value-of select="@key"/>
	</xsl:when>
	<xsl:otherwise>
		<xsl:value-of select="."/>
	</xsl:otherwise>
</xsl:choose>
</xsl:template>

<!--
########################################################################
	Device  (sizes mode)
########################################################################
-->
<xsl:template match="device" mode="sizes">

<xsl:for-each select=".//propref_DMP">
	<xsl:value-of select="concat(@size, ' ')"/>
</xsl:for-each>

<xsl:for-each select=".//includedev">
	<xsl:apply-templates mode="sizes"
			select="document(concat('DDL:', key('submod', @UUID)))//device">
	</xsl:apply-templates>
</xsl:for-each>

</xsl:template>

<!--
########################################################################
	Device (locs mode)
########################################################################
-->
<xsl:template match="device" mode="locs">
<xsl:param name="base" select="0"/>

<xsl:for-each select=".//propref_DMP">
	<xsl:value-of select="concat(sum(../../ancestor::property/protocol/childrule_DMP/@loc)
								+ $base + @loc, ' ')"/>
</xsl:for-each>

<xsl:for-each select=".//includedev">
	<xsl:apply-templates mode="locs"
			select="document(concat('DDL:', key('submod', @UUID)))//device">
		<xsl:with-param name="base" select="sum(ancestor-or-self::*/protocol/childrule_DMP/@loc) + $base"/>
	</xsl:apply-templates>
</xsl:for-each>

</xsl:template>

<!--
########################################################################
	Device (count mode)
########################################################################
-->
<xsl:template match="device" mode="count">

<xsl:value-of select="concat(count(.//propref_DMP), ' ')"/>

<xsl:for-each select=".//includedev">
	<xsl:apply-templates mode="count"
			select="document(concat('DDL:', key('submod', @UUID)))//device">
	</xsl:apply-templates>
</xsl:for-each>

</xsl:template>
<!--
########################################################################
	Generic recursive operation across string
########################################################################
-->
<xsl:template name="stringop">
<xsl:param name="numstr"/>
<xsl:param name="op"/>

<xsl:variable name="mystr" select="substring-before($numstr, ' ')"/>
<xsl:variable name="others" select="substring-after($numstr, ' ')"/>

	<xsl:choose>
		<xsl:when test="not($others)">
			<xsl:value-of select="$mystr"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="opot">
				<xsl:call-template name="stringop">
					<xsl:with-param name="numstr" select="$others"/>
					<xsl:with-param name="op" select="$op"/>
				</xsl:call-template>
			</xsl:variable>
	
			<xsl:choose>
				<xsl:when test="$op = 'sum'">
					<xsl:value-of select="$mystr + $opot"/>
				</xsl:when>
				<xsl:when test="$op = 'max' and $opot &gt; $mystr">
					<xsl:value-of select="$opot"/>
				</xsl:when>
				<xsl:when test="$op = 'min' and $opot &lt; $mystr">
					<xsl:value-of select="$opot"/>
				</xsl:when>
				<xsl:when test="$op = 'product'">
					<xsl:value-of select="$mystr * $opot"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$mystr"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<!--
########################################################################
	suppress output of text values
########################################################################
-->
<xsl:template match="text()|@*" mode="*">
</xsl:template>

</xsl:stylesheet>
